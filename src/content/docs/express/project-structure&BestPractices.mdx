---
title: "Project Structure & Best practices"
description: "Project Structure & Best practices"
---


# Express.js project structure 
This document outlines the standard project structure we use for Express.js applications. 
This structure follows best practices for organizing code in a modular, maintainable way.

## Directory Structure Overview
<pre>
     <code>
       {`project-root/
       ├── app.js                  # Application entry point
       ├── package.json            # Project dependencies and scripts
       ├── .env                    # Environment variables (not committed to version control)
       ├── .gitignore              # Specifies files to ignore in version control
       ├── config/                 # Configuration files
       ├── controllers/            # Request handlers
       ├── db/                     # Database setup and connection
       ├── middlewares/            # Custom middleware functions
       ├── models/                 # Data models
       ├── public/                 # Static files
       ├── routes/                 # Route definitions
       ├── services/               # Business logic
       ├── utils/                  # Utility functions
       ├── tests/                  # Test files
       └── views/                  # Template files (if using server-side rendering)`}
     </code>
   </pre>

## Directory Purposes
<p>
  <code>/app.js</code>
  --The application entry point that sets up the Express application, configures middleware, and connects routes.
</p> 



<p>
  <code>/config/</code>
  --Contains configuration files for different environments (development, testing, production).
</p>

<p>
  <code>/controllers/</code>
  --Contains controller functions that handle requests and responses. Each controller typically corresponds to a specific resource.
</p>

<p>
 <code>/db/</code>
 --Contains database-related files such as connection setup, migrations, and seeds.
</p>

<p>
 <code>/middlewares/</code>
 --Contains custom middleware functions that process requests before they reach route handlers.
</p>

<p>
 <code>/models/</code>
 --Contains data models that define the structure of data in the database.
</p>

<p>
 <code>/public/</code>
 --Contains static files that can be directly accessed by clients, such as images, CSS, and client-side JavaScript.
</p>

<p>
 <code>/routes/</code>
 --Contains route definitions that map HTTP methods and URLs to controller functions.
</p>

<p>
 <code>/services/ </code>
 --Contains business logic separated from controllers. Services handle data processing, interactions with models, and external API calls.
</p>

<p>
 <code> /utils/ </code>
 --Contains utility functions that can be used across the application.
</p>

<p>
 <code>/views/</code>
--Contains template files if your application uses server-side rendering.
</p>


## Here's a Complete File Tree Example

import { FileTree } from '@astrojs/starlight/components';

<FileTree>
  - express-project/
    - **app.js**
    - package.json
    - .env
    - .gitignore
    - README.md
    - config/
      - config.js
      - database.js
    - controllers/
      - authController.js
      - userController.js
      - productController.js
    - db/
      - connection.js
      - migrations/
      - seeds/
    - middlewares/
      - auth.js
      - errorHandler.js
      - validator.js
    - models/
      - userModel.js
      - productModel.js
    - public/
      - images/
      - stylesheets/
      - javascripts/
    - routes/
      - index.js
      - authRoutes.js
      - userRoutes.js
      - productRoutes.js
    - services/
      - authService.js
      - userService.js
      - productService.js
    - utils/
      - logger.js
      - apiFeatures.js
      - errorResponse.js
    - tests/
      - unit/
        - userController.test.js
        - authService.test.js
      - integration/
        - auth.test.js
        - user.test.js
    - views/
      - index.ejs
      - login.ejs
      - partials/
        - header.ejs
        - footer.ejs
</FileTree>
# Express.js to NestJS

Transitioning from **Express.js** to **NestJS** depends on several factors, including **project complexity, scalability needs, maintainability, and team expertise**.

## When Should You Switch to NestJS?

| Factor               | Express.js | NestJS | When to Transition? |
|----------------------|------------|--------|----------------------|
| **Project Complexity** | Best for simple to medium-sized projects | Best for large-scale, enterprise applications | When the project grows in complexity and needs modular organization |
| **Architecture** | Unstructured, manually organized | Uses a modular, opinionated structure | When you need better separation of concerns and scalability |
| **Scalability** | Needs manual structuring for microservices support | Built-in support for microservices with modularity | When planning a microservices-based architecture |
| **TypeScript Support** | Optional but not enforced | Built-in TypeScript support | When adopting TypeScript for better maintainability |
| **Performance** | Lightweight, flexible | Slightly heavier but well-optimized | When structure and maintainability outweigh minimal performance gains |
| **Built-in Features** | Requires third-party libraries for validation, DI, and testing | Has built-in dependency injection (DI), validation, guards, interceptors | When you need more maintainable, testable, and structured code |
| **Team Skills** | Easier for beginners, minimal learning curve | Requires understanding of TypeScript and architecture concepts | When the team is comfortable with TypeScript and modular design |

## Simple Example: Express.js vs. NestJS

### **Express.js Implementation**
Here’s a basic Express.js REST API with one route:

```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/hello', (req, res) => {
  res.json({ message: 'Hello from Express.js!' });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

---

### **NestJS Equivalent**
To achieve the same functionality in **NestJS**, follow these steps:

#### **Step 1: Install NestJS CLI & Create a New Project**
```sh
npm i -g @nestjs/cli
nest new my-nest-app
cd my-nest-app
```

#### **Step 2: Create a Controller**
Generate a new controller:
```sh
nest generate controller hello
```
It will create a file `hello.controller.ts` inside `src/hello/`:

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('hello')
export class HelloController {
  @Get()
  getHello(): object {
    return { message: 'Hello from NestJS!' };
  }
}
```

#### **Step 3: Register the Controller**
NestJS automatically registers controllers, but ensure it’s included in the module:

```typescript
import { Module } from '@nestjs/common';
import { HelloController } from './hello/hello.controller';

@Module({
  controllers: [HelloController],
})
export class AppModule {}
```

#### **Step 4: Run the Application**
```sh
npm run start:dev
```
---
## Conclusion: When to Make the Switch

 **Stay with Express.js** if:
- The project is simple, like a small API or microservice.
- You need maximum flexibility and lightweight performance.
- Your team is new to TypeScript and doesn’t require strict modularity.

 **Move to NestJS** if:
- The project is growing and needs **better maintainability, structure, and scalability**.
- You plan to **use TypeScript and a modular architecture**.
- The application requires **dependency injection, middleware, and built-in support for testing and validation**.

## More about Transition To NestJS
 This [article](https://bhargavacharyb.medium.com/transition-from-express-to-nestjs-aeffc7d53585) offers a <mark>`step-by-step`</mark> migration process, including configuring TypeScript and converting routes.

# Managing Environment Variables with `dotenv`

Environment variables provide a secure and flexible way to manage configuration settings across different environments. Using dotenv allows you to load environment variables from a `.env` file into `process.env`.

## Installing `dotenv`
To install `dotenv`, run:
```sh
npm install dotenv
```

## Setting Up an `.env` File
Create a `.env` file in the root of your project:
```env
PORT=5000
DB_HOST=localhost
DB_USER=admin
DB_PASS=secretpassword
```

# Loading Environment Variables in Node.js

Environment variables are essential for keeping sensitive information secure and configuring your application for different environments. Here's how to load them in Node.js:

import { Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
  <TabItem value="commonjs" label="CommonJS" default>
    ## CommonJS Approach

    ### 1. Install dotenv

    ```bash
    npm install dotenv
    ```

    ### 2. Create a .env file in your project root

    ```
    PORT=3000
    DB_HOST=localhost
    DB_USER=root
    DB_PASS=password
    DB_NAME=myapp
    ```

    ### 3. In your application entry file (e.g., app.js)

    ```javascript
    // Load environment variables
    require('dotenv').config();

    // Access environment variables
    const port = process.env.PORT || 3000;
    const dbHost = process.env.DB_HOST;
    const dbUser = process.env.DB_USER;
    const dbPass = process.env.DB_PASS;
    const dbName = process.env.DB_NAME;

    console.log(`Server running on port: ${port}`);
    console.log(`Database Host: ${dbHost}`);

    // Example Express setup
    const express = require('express');
    const app = express();

    app.listen(port, () => {
      console.log(`Server is running on port ${port}`);
    });
    ```

    > **Note:** Make sure to add `.env` to your `.gitignore` file to avoid exposing sensitive information in your repository.
  </TabItem>
  
  <TabItem value="esmodules" label="ES Modules">
    ## ES Modules Approach

    ### 1. Install dotenv

    ```bash
    npm install dotenv
    ```

    ### 2. Create a .env file in your project root

    ```
    PORT=3000
    DB_HOST=localhost
    DB_USER=root
    DB_PASS=password
    DB_NAME=myapp
    ```

    ### 3. In your application entry file (e.g., index.js)

    ```javascript
    // Load environment variables
    import * as dotenv from 'dotenv';
    dotenv.config();

    // Access environment variables
    const port = process.env.PORT || 3000;
    const dbHost = process.env.DB_HOST;
    const dbUser = process.env.DB_USER;
    const dbPass = process.env.DB_PASS;
    const dbName = process.env.DB_NAME;

    console.log(`Server running on port: ${port}`);
    console.log(`Database Host: ${dbHost}`);

    // Example Express setup
    import express from 'express';
    const app = express();

    app.listen(port, () => {
      console.log(`Server is running on port ${port}`);
    });
    ```

    ### 4. Make sure your package.json has "type": "module" to use ES Modules

    ```json
    {
      "name": "my-app",
      "version": "1.0.0",
      "type": "module",
      "scripts": {
        "start": "node index.js"
      },
      "dependencies": {
        "dotenv": "^16.3.1",
        "express": "^4.18.2"
      }
    }
    ```

    > **Note:** Make sure to add `.env` to your `.gitignore` file to avoid exposing sensitive information in your repository.
  </TabItem>
</Tabs>

## Advanced Configuration

For more complex applications, you might want to:

1. **Use different environment files** for different environments:
   - `.env.development`
   - `.env.production`
   - `.env.test`

2. **Validate environment variables** to ensure all required variables are set:

```javascript
function validateEnv() {
  const required = ['DB_HOST', 'DB_USER', 'DB_PASS'];
  
  for (const variable of required) {
    if (!process.env[variable]) {
      throw new Error(`Missing required environment variable: ${variable}`);
    }
  }
  
  console.log('Environment validation passed');
}

// Call after loading environment variables
validateEnv();
```

3. **Set defaults** for missing environment variables:

```javascript
const config = {
  port: process.env.PORT || 3000,
  dbHost: process.env.DB_HOST || 'localhost',
  nodeEnv: process.env.NODE_ENV || 'development'
};
```

This approach ensures your application is properly configured regardless of whether all environment variables are explicitly set.
# Approach to Configuration Management

To maintain a **structured and scalable** configuration management strategy, we use a dedicated `config` module instead of accessing `process.env` throughout the code.


# Creating Configuration Files in Node.js

A best practice in Node.js applications is to centralize your configuration settings. This makes your application more maintainable and allows for easier environment-specific configuration.

## Creating a Configuration File

<Tabs>
  <TabItem value="commonjs" label="CommonJS" default>
    Create a `config.js` file:

    ```javascript
    require('dotenv').config();
    const config = {
      server: {
        port: process.env.PORT || 3000,
      },
      database: {
        host: process.env.DB_HOST || 'localhost',
        user: process.env.DB_USER || 'root',
        password: process.env.DB_PASS || '',
      },
    };
    module.exports = config;
    ```
  </TabItem>
  
  <TabItem value="esmodules" label="ES Modules">
    Create a `config.js` file:

    ```javascript
    import * as dotenv from 'dotenv';
    dotenv.config();

    const config = {
      server: {
        port: process.env.PORT || 3000,
      },
      database: {
        host: process.env.DB_HOST || 'localhost',
        user: process.env.DB_USER || 'root',
        password: process.env.DB_PASS || '',
      },
    };

    export default config;
    ```
  </TabItem>
</Tabs>

## Using the Configuration Module

<Tabs>
  <TabItem value="commonjs-usage" label="CommonJS" default>
    Import and use the configuration in your application files:

    ```javascript
    const config = require('./config');
    console.log(`Server will run on port: ${config.server.port}`);
    console.log(`Connecting to database at: ${config.database.host}`);

    // Example Express setup
    const express = require('express');
    const app = express();

    app.listen(config.server.port, () => {
      console.log(`Server is running on port ${config.server.port}`);
    });
    ```
  </TabItem>
  
  <TabItem value="esmodules-usage" label="ES Modules">
    Import and use the configuration in your application files:

    ```javascript
    import config from './config.js';
    console.log(`Server will run on port: ${config.server.port}`);
    console.log(`Connecting to database at: ${config.database.host}`);

    // Example Express setup
    import express from 'express';
    const app = express();

    app.listen(config.server.port, () => {
      console.log(`Server is running on port ${config.server.port}`);
    });
    ```
  </TabItem>
</Tabs>


## **Benefits of Using `dotenv` and Configuration Management**

**Security:** Keeps sensitive credentials (e.g., API keys, passwords) out of the source code. Prevents accidental exposure in version control (always add `.env` to `.gitignore`).

**Flexibility & Scalability** Easily switch configurations between development, testing, and production environments. Simplifies maintenance as projects grow.

**Code Cleanliness & Maintainability** Avoids hardcoded values in multiple files, improving readability. Allows centralized management of configurations.

**Environment-Specific Customization** Developers can define different `.env` files for **development (`.env.development`)**, **staging (`.env.staging`)**, and **production (`.env.production`)**.

### Development (.env.development)
```
NODE_ENV=development
DATABASE_URL=postgresql://dev:dev@localhost:5432/dev_db
API_KEY=dev_api_key
DEBUG=true
```

### Testing (.env.test)
```
NODE_ENV=test
DATABASE_URL=postgresql://test:test@localhost:5432/test_db
API_KEY=test_api_key
DEBUG=true
```
## **For More understanding the** `dot.env`  **Check**:

import { LinkCard } from '@astrojs/starlight/components';

<LinkCard title="dotenv link Documentation" href="https://www.npmjs.com/package/dotenv"  description="Covers installation, usage, and advanced features like variable expansion."  />

