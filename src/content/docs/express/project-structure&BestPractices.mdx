---
title: "Project Structure"
description: "Project Structure"
---


# Express.js project structure 
This document outlines the standard project structure we use for Express.js applications. 
This structure follows best practices for organizing code in a modular, maintainable way.

## Directory Structure Overview
<pre>
     <code>
       {`project-root/
       ├── app.js                  # Application entry point
       ├── server.js               # Server initialization
       ├── package.json            # Project dependencies and scripts
       ├── .env                    # Environment variables (not committed to version control)
       ├── .gitignore              # Specifies files to ignore in version control
       ├── config/                 # Configuration files
       ├── controllers/            # Request handlers
       ├── db/                     # Database setup and connection
       ├── middlewares/            # Custom middleware functions
       ├── models/                 # Data models
       ├── public/                 # Static files
       ├── routes/                 # Route definitions
       ├── services/               # Business logic
       ├── utils/                  # Utility functions
       ├── tests/                  # Test files
       └── views/                  # Template files (if using server-side rendering)`}
     </code>
   </pre>

## Directory Purposes

<p>
  <code>/app.js</code>
</p>

The application entry point that sets up the Express application, configures middleware, and connects routes.

<p>
  <code>/server.js</code>
</p>

Initializes the server and starts listening on a specified port. Separating this from `/app.js` makes testing easier.

<p>
  <code>/config/</code>
</p>

Contains configuration files for different environments (development, testing, production).
<p>
  <code>/controllers/</code>
</p>

Contains controller functions that handle requests and responses. Each controller typically corresponds to a specific resource.
<p>
 <code>/db/</code>
</p>

Contains database-related files such as connection setup, migrations, and seeds.

<p>
 <code>/middlewares/</code>
</p>

Contains custom middleware functions that process requests before they reach route handlers.

<p>
 <code>/models/</code>
</p>

Contains data models that define the structure of data in the database.

<p>
 <code>/public/</code>
</p>

Contains static files that can be directly accessed by clients, such as images, CSS, and client-side JavaScript.

<p>
 <code>/routes/</code>
</p>

Contains route definitions that map HTTP methods and URLs to controller functions.

<p>
 <code>/services/ </code>
</p>

Contains business logic separated from controllers. Services handle data processing, interactions with models, and external API calls.

<p>
 <code> /utils/ </code>
</p>

Contains utility functions that can be used across the application.

<p>
 <code>/views/</code>
</p>

Contains template files if your application uses server-side rendering.

## Here's a Complete File Tree Example

import { FileTree } from '@astrojs/starlight/components';

<FileTree>
  - express-project/
    - **app.js**
    - server.js
    - package.json
    - .env
    - .gitignore
    - README.md
    - config/
      - config.js
      - database.js
    - controllers/
      - authController.js
      - userController.js
      - productController.js
    - db/
      - connection.js
      - migrations/
      - seeds/
    - middlewares/
      - auth.js
      - errorHandler.js
      - validator.js
    - models/
      - userModel.js
      - productModel.js
    - public/
      - images/
      - stylesheets/
      - javascripts/
    - routes/
      - index.js
      - authRoutes.js
      - userRoutes.js
      - productRoutes.js
    - services/
      - authService.js
      - userService.js
      - productService.js
    - utils/
      - logger.js
      - apiFeatures.js
      - errorResponse.js
    - tests/
      - unit/
        - userController.test.js
        - authService.test.js
      - integration/
        - auth.test.js
        - user.test.js
    - views/
      - index.ejs
      - login.ejs
      - partials/
        - header.ejs
        - footer.ejs
</FileTree>
# Express.js to NestJS

Transitioning from **Express.js** to **NestJS** depends on several factors, including **project complexity, scalability needs, maintainability, and team expertise**.

## When Should You Switch to NestJS?

| Factor               | Express.js | NestJS | When to Transition? |
|----------------------|------------|--------|----------------------|
| **Project Complexity** | Best for simple to medium-sized projects | Best for large-scale, enterprise applications | When the project grows in complexity and needs modular organization |
| **Architecture** | Unstructured, manually organized | Uses a modular, opinionated structure | When you need better separation of concerns and scalability |
| **Scalability** | Needs manual structuring for microservices support | Built-in support for microservices with modularity | When planning a microservices-based architecture |
| **TypeScript Support** | Optional but not enforced | Built-in TypeScript support | When adopting TypeScript for better maintainability |
| **Performance** | Lightweight, flexible | Slightly heavier but well-optimized | When structure and maintainability outweigh minimal performance gains |
| **Built-in Features** | Requires third-party libraries for validation, DI, and testing | Has built-in dependency injection (DI), validation, guards, interceptors | When you need more maintainable, testable, and structured code |
| **Team Skills** | Easier for beginners, minimal learning curve | Requires understanding of TypeScript and architecture concepts | When the team is comfortable with TypeScript and modular design |

## Simple Example: Express.js vs. NestJS

### **Express.js Implementation**
Here’s a basic Express.js REST API with one route:

```javascript
const express = require('express');
const app = express();
const port = 3000;

app.get('/hello', (req, res) => {
  res.json({ message: 'Hello from Express.js!' });
});

app.listen(port, () => {
  console.log(`Server running at http://localhost:${port}`);
});
```

---

### **NestJS Equivalent**
To achieve the same functionality in **NestJS**, follow these steps:

#### **Step 1: Install NestJS CLI & Create a New Project**
```sh
npm i -g @nestjs/cli
nest new my-nest-app
cd my-nest-app
```

#### **Step 2: Create a Controller**
Generate a new controller:
```sh
nest generate controller hello
```
It will create a file `hello.controller.ts` inside `src/hello/`:

```typescript
import { Controller, Get } from '@nestjs/common';

@Controller('hello')
export class HelloController {
  @Get()
  getHello(): object {
    return { message: 'Hello from NestJS!' };
  }
}
```

#### **Step 3: Register the Controller**
NestJS automatically registers controllers, but ensure it’s included in the module:

```typescript
import { Module } from '@nestjs/common';
import { HelloController } from './hello/hello.controller';

@Module({
  controllers: [HelloController],
})
export class AppModule {}
```

#### **Step 4: Run the Application**
```sh
npm run start
```
Your NestJS server will run on `http://localhost:3000/hello` and return the response `{ message: "Hello from NestJS!" }`.

---
## Conclusion: When to Make the Switch

 **Stay with Express.js** if:
- The project is simple, like a small API or microservice.
- You need maximum flexibility and lightweight performance.
- Your team is new to TypeScript and doesn’t require strict modularity.

 **Move to NestJS** if:
- The project is growing and needs **better maintainability, structure, and scalability**.
- You plan to **use TypeScript and a modular architecture**.
- The application requires **dependency injection, middleware, and built-in support for testing and validation**.

## More about Transition To NestJS
 This [article](https://bhargavacharyb.medium.com/transition-from-express-to-nestjs-aeffc7d53585) offers a <mark>`step-by-step`</mark> migration process, including configuring TypeScript and converting routes.

# Managing Environment Variables with `dotenv`

Environment variables provide a secure and flexible way to manage configuration settings across different environments. Using dotenv allows you to load environment variables from a `.env` file into `process.env`.

## Installing `dotenv`
To install `dotenv`, run:
```sh
npm install dotenv
```

## Setting Up an `.env` File
Create a `.env` file in the root of your project:
```env
PORT=5000
DB_HOST=localhost
DB_USER=admin
DB_PASS=secretpassword
```

## Loading Environment Variables in Node.js
In your application entry file (e.g., `server.js` or `index.js`), add:
```javascript
require('dotenv').config();

console.log('Server running on port:', process.env.PORT);
console.log('Database Host:', process.env.DB_HOST);
```
# Approach to Configuration Management

To maintain a **structured and scalable** configuration management strategy, we use a dedicated `config` module instead of accessing `process.env` throughout the code.

## Creating a Configuration File
Create a `config.js` file:
```javascript
require('dotenv').config();

const config = {
  server: {
    port: process.env.PORT || 3000,
  },
  database: {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASS || '',
  },
};

module.exports = config;
```

## Using the Configuration Module
Import and use the configuration in your application files:
```javascript
const config = require('./config');

console.log(`Server will run on port: ${config.server.port}`);
console.log(`Connecting to database at: ${config.database.host}`);
```
## **Benefits of Using `dotenv` and Configuration Management**

**Security:** Keeps sensitive credentials (e.g., API keys, passwords) out of the source code. Prevents accidental exposure in version control (always add `.env` to `.gitignore`).

**Flexibility & Scalability** Easily switch configurations between development, testing, and production environments. Simplifies maintenance as projects grow.

**Code Cleanliness & Maintainability** Avoids hardcoded values in multiple files, improving readability. Allows centralized management of configurations.

**Environment-Specific Customization** Developers can define different `.env` files for **development (`.env.development`)**, **staging (`.env.staging`)**, and **production (`.env.production`)**.

### Development (.env.development)
```
NODE_ENV=development
DATABASE_URL=postgresql://dev:dev@localhost:5432/dev_db
API_KEY=dev_api_key
DEBUG=true
```

### Testing (.env.test)
```
NODE_ENV=test
DATABASE_URL=postgresql://test:test@localhost:5432/test_db
API_KEY=test_api_key
DEBUG=true
```
## **For More understanding the** `dot.env`  **Check**:

import { LinkCard } from '@astrojs/starlight/components';

<LinkCard title="dotenv link Documentation" href="https://www.npmjs.com/package/dotenv"  description="Covers installation, usage, and advanced features like variable expansion."  />

