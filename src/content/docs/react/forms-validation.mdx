---
title: "Forms & Validation"
description: "Essential React form handling patterns with React Hook Form, multi-step forms, validation strategies, and UX best practices for loading states and user feedback."
---

import { Aside, Tabs, TabItem } from '@astrojs/starlight/components';

Forms are crucial for user interaction in React applications. This guide covers React Hook Form fundamentals, multi-step form patterns, validation strategies, and UX best practices for creating smooth form experiences.

## Why React Hook Form?

Traditional React forms often suffer from performance issues due to frequent re-renders. Every keystroke in a controlled input can trigger a re-render of the entire form component. React Hook Form solves this by using uncontrolled components and refs, which means:

- **Better Performance**: Only re-renders when necessary (validation errors, form submission)
- **Less Boilerplate**: No need to manage state for each input individually
- **Built-in Validation**: Comprehensive validation with clear error messaging
- **DevTools Integration**: Excellent developer experience with browser dev tools

### Installation and Basic Setup

```bash title="Terminal"
npm install react-hook-form
```

The core concept is simple: register your inputs, handle form submission, and let React Hook Form manage the rest.

```jsx title="components/ContactForm.jsx"
import { useForm } from 'react-hook-form';

const ContactForm = () => {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm({
    defaultValues: {
      name: '',
      email: ''
    }
  });

  const onSubmit = async (data) => {
    // data contains all form values: { name: "...", email: "..." }
    await submitToAPI(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input 
        {...register('name', { required: 'Name is required' })} 
        placeholder="Your name" 
      />
      {errors.name && <span>{errors.name.message}</span>}
      
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Submit'}
      </button>
    </form>
  );
};
```

**Key Concepts:**
- `register()` connects your input to React Hook Form's internal state
- `handleSubmit()` wraps your submit function and handles validation automatically
- `formState` provides useful information about form status
- Validation rules are defined inline with the register function

### Default Values Are Essential

Always provide default values in your useForm configuration. This prevents common issues:

- **Controlled vs Uncontrolled Warning**: React warns when inputs switch between controlled and uncontrolled
- **TypeScript Safety**: Default values ensure your form data structure is predictable
- **Better UX**: Users see empty fields instead of `undefined` values
- **Easier Testing**: Consistent initial state makes testing more reliable

```jsx
// ❌ Bad: No default values
const { register } = useForm();

// ✅ Good: Clear default values
const { register } = useForm({
  defaultValues: {
    name: '',
    email: '',
    age: 0,
    preferences: {
      newsletter: false,
      notifications: true
    }
  }
});
```

<Aside type="tip">
  Match your default values structure to your expected form data. This makes it easier to handle form submissions and prevents runtime errors.
</Aside>

## Advanced Validation Strategies

### When to Use Schema Validation

For simple forms, inline validation works perfectly. But when forms become complex with cross-field validation, conditional logic, or need TypeScript integration, schema validation becomes essential.

**Schema validation is recommended when you have:**
- Complex validation rules that span multiple fields
- Need for TypeScript type safety
- Reusable validation logic across different forms
- Server-side and client-side validation consistency

### Zod Integration Example

```bash title="Terminal"
npm install zod @hookform/resolvers
```

```jsx title="components/RegistrationForm.jsx"
import { z } from 'zod';
import { zodResolver } from '@hookform/resolvers/zod';

// Define your validation schema once, use everywhere
const registrationSchema = z.object({
  username: z.string().min(3, 'Too short').max(20, 'Too long'),
  email: z.string().email('Invalid email'),
  password: z.string().min(8, 'Password too weak'),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

const RegistrationForm = () => {
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(registrationSchema),
    defaultValues: {
      username: '',
      email: '',
      password: '',
      confirmPassword: ''
    }
  });

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('username')} placeholder="Username" />
      {errors.username && <span>{errors.username.message}</span>}
      
      <input {...register('password')} type="password" placeholder="Password" />
      {errors.password && <span>{errors.password.message}</span>}
      
      <button type="submit">Register</button>
    </form>
  );
};
```

**Why This Approach Works:**
- **Single Source of Truth**: Schema defines both validation and TypeScript types
- **Reusability**: Same schema can validate on server and client
- **Better Error Messages**: Zod provides clear, customizable error messages
- **Type Safety**: Automatic TypeScript integration with `z.infer<typeof schema>`

## Multi-Step Forms

Multi-step forms solve the problem of overwhelming users with long, complex forms. Instead of presenting everything at once, you break the form into logical sections that users complete sequentially.

### Why Multi-Step Forms Work

**Technical Benefits:**
- **Better Validation**: Validate each section before proceeding
- **Conditional Logic**: Show/hide sections based on previous answers
- **Save Progress**: Allow users to return and complete later

### Implementation Strategy

The key to good multi-step forms is maintaining form state across steps while validating each step independently.

<Tabs>
<TabItem label="Multi-Step Hook">

```jsx title="hooks/useMultiStepForm.js"
import { useState } from 'react';

// Custom hook for managing steps
const useMultiStepForm = (totalSteps) => {
  const [currentStep, setCurrentStep] = useState(0);
  
  const nextStep = () => setCurrentStep(prev => Math.min(prev + 1, totalSteps - 1));
  const prevStep = () => setCurrentStep(prev => Math.max(prev - 1, 0));
  const goToStep = (step) => setCurrentStep(step);
  
  return {
    currentStep,
    nextStep,
    prevStep,
    goToStep,
    isFirstStep: currentStep === 0,
    isLastStep: currentStep === totalSteps - 1,
    progress: ((currentStep + 1) / totalSteps) * 100
  };
};

export default useMultiStepForm;
```

</TabItem>
<TabItem label="Form Component">

```jsx title="components/MultiStepForm.jsx"
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import useMultiStepForm from '../hooks/useMultiStepForm';

// Zod schema for multi-step validation
const multiStepSchema = z.object({
  // Step 1: Personal Info
  firstName: z.string().min(2, 'First name must be at least 2 characters'),
  lastName: z.string().min(2, 'Last name must be at least 2 characters'),
  dateOfBirth: z.string().min(1, 'Date of birth is required'),
  
  // Step 2: Account Details
  username: z.string().min(3, 'Username must be at least 3 characters'),
  email: z.string().email('Invalid email address'),
  password: z.string().min(6, 'Password must be at least 6 characters'),
  
  // Step 3: Preferences
  newsletter: z.boolean(),
  notifications: z.boolean()
});

const MultiStepForm = () => {
  const { register, handleSubmit, trigger, formState: { errors } } = useForm({
    resolver: zodResolver(multiStepSchema), // Use Zod for validation
    defaultValues: {
      firstName: '',
      lastName: '',
      dateOfBirth: '',
      username: '',
      email: '',
      password: '',
      newsletter: false,
      notifications: true
    }
  });
  
  const { currentStep, nextStep, prevStep, isFirstStep, isLastStep, progress } = useMultiStepForm(3);

  // Helper function to define which fields belong to each step
  const getFieldsForCurrentStep = (step) => {
    const fieldsByStep = {
      0: ['firstName', 'lastName', 'dateOfBirth'],
      1: ['username', 'email', 'password'],
      2: ['newsletter', 'notifications']
    };
    return fieldsByStep[step] || [];
  };

  const validateStep = async () => {
    const fieldsToValidate = getFieldsForCurrentStep(currentStep);
    return await trigger(fieldsToValidate); // Only validate current step fields
  };

  const handleNext = async () => {
    const isValid = await validateStep(); // Check if current step is valid
    if (isValid) nextStep(); // Only advance if valid
  };

  const onSubmit = async (data) => {
    console.log('Form submitted:', data);
    // Handle final form submission
  };

  const renderStepContent = () => {
    switch (currentStep) {
      case 0: return <PersonalInfoStep register={register} errors={errors} />;
      case 1: return <AccountDetailsStep register={register} errors={errors} />;
      case 2: return <ReviewStep watch={watch} />;
      default: return null;
    }
  };

  return (
    <div className="max-w-md mx-auto">
      {/* Progress indicator */}
      <div className="w-full bg-gray-200 rounded-full h-2 mb-6">
        <div 
          className="bg-gdg-blue h-2 rounded-full transition-all duration-300"
          style={{ width: `${progress}%` }}
        />
      </div>

      <form onSubmit={handleSubmit(onSubmit)}>
        {renderStepContent()}
        
        <div className="flex justify-between mt-6">
          {!isFirstStep && (
            <button type="button" onClick={prevStep}>Previous</button>
          )}
          
          {!isLastStep ? (
            <button type="button" onClick={handleNext}>Next</button>
          ) : (
            <button type="submit">Submit</button>
          )}
        </div>
      </form>
    </div>
  );
};

export default MultiStepForm;
```

</TabItem>
</Tabs>

**Key Multi-Step Principles:**
- **Validate Before Advancing**: Don't let users proceed with invalid data
- **Show Progress**: Users need to know how much is left
- **Allow Navigation**: Let users go back to previous steps
- **Maintain State**: All form data should persist across steps
- **Clear Step Titles**: Make it obvious what each step covers

## UX Best Practices

Great forms aren't just about collecting data—they're about creating a smooth, trustworthy experience that users actually want to complete.

### Loading States and User Feedback

**Why Loading States Matter:**
Users need to know their action is being processed. Without feedback, they might:
- Click submit multiple times (causing duplicate submissions)
- Think the form is broken and leave
- Lose trust in your application

**Essential Loading State Patterns:**

```jsx title="components/FormWithFeedback.jsx"
const FormWithFeedback = () => {
  const { register, handleSubmit, formState: { isSubmitting, isValid } } = useForm({
    defaultValues: {
      email: '',
      message: ''
    },
    mode: 'onChange' // Enables real-time validation for isValid
  });
  const [submitStatus, setSubmitStatus] = useState(null);

  const onSubmit = async (data) => {
    setSubmitStatus('submitting');
    try {
      await submitData(data);
      setSubmitStatus('success');
    } catch (error) {
      setSubmitStatus('error');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('email', { required: true })} />
      
      {/* Dynamic submit button */}
      <button 
        type="submit" 
        disabled={!isValid || isSubmitting} // Disable if form invalid OR submitting
        className={isSubmitting ? 'loading' : ''}
      >
        {isSubmitting ? 'Sending...' : 'Submit'} {/* Show loading text during submission */}
      </button>

      {/* Status messages */}
      {submitStatus === 'success' && <p>✓ Form submitted successfully!</p>}
      {submitStatus === 'error' && <p>✗ Please try again</p>}
    </form>
  );
};
```

### Form Validation UX Patterns

**When to Validate:**
- **On Submit**: Always validate before submission (prevents server errors)
- **On Blur**: Validate after user leaves a field (immediate feedback)
- **On Change**: For complex fields like passwords (real-time strength checking)

**Progressive Enhancement Strategy:**
1. Start with basic HTML validation (`required`, `type="email"`)
2. Add JavaScript validation for better UX
3. Always validate on the server for security

### Performance Optimization

**Form Performance Best Practices:**
- **Debounce Expensive Validation**: Don't validate on every keystroke for API calls
- **Lazy Load Complex Forms**: Load form libraries only when needed
- **Optimize Re-renders**: React Hook Form already minimizes this, but be aware in custom components
- **Bundle Size**: Consider form library size in your bundle analysis

### Error Handling Strategy

**Effective Error Handling:**
1. **Prevent Errors**: Good UX design prevents most user errors
2. **Clear Messages**: Tell users exactly what's wrong and how to fix it
3. **Inline Errors**: Show errors next to the relevant field
4. **Recovery Path**: Always provide a way to fix and retry

## Best Practices Summary

### Form Design Philosophy

**Start Simple, Scale Smart:**
- Begin with basic HTML validation and React Hook Form
- Add schema validation (Zod) when complexity increases
- Implement multi-step patterns for long forms
- Always prioritize user experience over technical complexity

### Validation Strategy

**Three-Layer Validation Approach:**
1. **Client-side**: Immediate feedback and better UX
2. **Server-side**: Security and data integrity (never skip this)
3. **Database**: Final constraint enforcement

### Performance Guidelines

**Key Performance Considerations:**
- React Hook Form already optimizes re-renders
- Use `mode: 'onChange'` judiciously (can impact performance on large forms)
- Debounce expensive validation (API calls, complex calculations)
- Consider bundle size when adding form libraries

### Security Reminders

**Essential Security Practices:**
- Always validate on the server
- Sanitize user input before processing
- Be careful with file uploads (validate type, size, scan for malware)

<Aside type="tip">
  **Development Tip**: Use React Hook Form's DevTools extension to debug form state and validation issues during development. It provides valuable insights into form behavior.
</Aside>

## Further Reading

- [React Hook Form Documentation](https://react-hook-form.com/)
- [Zod Schema Validation](https://zod.dev/)
