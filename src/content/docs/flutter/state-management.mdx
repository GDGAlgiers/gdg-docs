---
title: "State Management"
description: "Understanding state management approaches in Flutter and why BLoC is preferred in our MVVM architecture."
---

import { Aside, Code, FileTree, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

State management is crucial for building scalable, maintainable, and efficient Flutter applications. It defines how data flows and changes in an app, impacting performance, modularity, and developer experience.

<Aside type="tip">
  **Pro tip:** Understanding state management is essential for building production-ready Flutter applications. It's worth taking the time to learn the different approaches thoroughly.
</Aside>

## Why is State Management Important?

State management provides several critical benefits for Flutter applications:

**Predictability**: Ensures a structured way to manage UI changes, making application behavior consistent and reliable across different user interactions.

**Performance Optimization**: Prevents unnecessary widget rebuilds by controlling exactly when and what parts of the UI need to update in response to state changes.

**Code Maintainability**: Separates concerns between UI, logic, and data layers, making code easier to understand, debug, and modify over time.

**Scalability**: Enables the app to grow without becoming difficult to manage, allowing teams to add features without disrupting existing functionality.

## State Management Approaches in Flutter

Flutter offers multiple ways to handle state, each with trade-offs. Below are some of the most popular approaches:

<Tabs>
  <TabItem label="Provider">
    ### Provider (Officially Recommended)
    
    Provider is Flutter's officially recommended state management solution for most applications:
    
    - **Lightweight and easy to use**: Minimal learning curve with straightforward API
    - **Built on top of ChangeNotifier**: Leverages Flutter's built-in change notification system
    - **Good for small-to-medium applications**: Handles moderate complexity without excessive boilerplate

    **Use Case:** Suitable for apps that require simple state changes and dependency injection without complex state transitions.

    <Code code={`// Example of Provider usage
class Counter with ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();
  }
}`} lang="dart" />
  </TabItem>

  <TabItem label="Riverpod">
    ### Riverpod (Provider's Successor)
    
    Riverpod addresses Provider's limitations with improved architecture:
    
    - **Eliminates BuildContext dependency**: Provides access to state from anywhere in the app
    - **Supports better performance optimizations**: More granular control over widget rebuilds
    - **Ensures state immutability**: Promotes safer state management patterns

    **Use Case:** Ideal for medium-to-large applications that need enhanced scalability and better testing capabilities.

    <Code code={`// Example of Riverpod usage
final counterProvider = StateProvider((ref) => 0);

class Counter extends ConsumerWidget {
  @override
  Widget build(BuildContext context, ScopedReader watch) {
    final count = watch(counterProvider).state;
    return Text('$count');
  }
}`} lang="dart" />
  </TabItem>

  <TabItem label="GetX">
    ### GetX (Minimal Boilerplate)
    
    GetX prioritizes simplicity and rapid development:
    
    - **Simple API and reactive state management**: Minimal code required for state updates
    - **Built-in dependency injection and navigation**: All-in-one solution for common app needs
    - **Less structured but very convenient**: Trade-offs between simplicity and architecture

    **Use Case:** Best for small projects or apps that prioritize rapid development over strict architectural patterns.

    <Code code={`// Example of GetX usage
class CounterController extends GetxController {
  var count = 0.obs;
  void increment() => count++;
}`} lang="dart" />
  </TabItem>

  <TabItem label="BLoC">
    ### BLoC (Business Logic Component)
    
    BLoC provides the most structured approach to state management:
    
    - **Implements a structured event-driven approach**: Clear separation between events and state changes
    - **Uses streams (Cubit or Bloc) to manage state**: Reactive programming with predictable data flow
    - **Promotes a clean separation of concerns**: Business logic isolated from UI components

    **Use Case:** Preferred for **large-scale** applications following the **MVVM pattern** due to its clear structure and comprehensive testability.

    <Code code={`// Example of BLoC usage
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0);

  void increment() => emit(state + 1);
}`} lang="dart" />
  </TabItem>
</Tabs>

## Why We Use BLoC for MVVM Architecture

<Aside type="note">
  In our architecture, we follow the **Model-View-ViewModel (MVVM)** pattern to separate UI from business logic.
</Aside>

BLoC aligns well with the MVVM approach for several key reasons:

**Encapsulated Business Logic**: BLoC keeps UI and logic completely independent, ensuring business rules remain separate from presentation concerns. This separation makes code more maintainable and testable.

**Event-driven Workflow**: The UI triggers events that BLoC processes, creating a clear unidirectional data flow. This pattern prevents UI components from directly manipulating business logic.

**Scalability & Maintainability**: BLoC's modular structure allows features to be developed independently while maintaining consistent patterns across the entire application.

**Consistency Across Features**: BLoC ensures a uniform way of handling state across all app features, making it easier for team members to understand and contribute to different parts of the codebase.

## How BLoC Works in Our Architecture

In our MVVM architecture, BLoC serves as the ViewModel layer that manages state and business logic:

<Steps>
  1. **Model**: Represents the data and business logic, including entities, repositories, and data sources
  2. **View**: The UI of the application that displays data and sends user interaction events
  3. **ViewModel (BLoC)**: Manages the state and handles the business logic, connecting the Model and View layers
</Steps>

<Code code={`// Example of BLoC in MVVM
class UserBloc extends Bloc<UserEvent, UserState> {
  final UserRepository userRepository;

  UserBloc(this.userRepository) : super(UserInitial());

  @override
  Stream<UserState> mapEventToState(UserEvent event) async* {
    if (event is LoadUser) {
      yield UserLoading();
      try {
        final user = await userRepository.getUser(event.userId);
        yield UserLoaded(user);
      } catch (_) {
        yield UserError();
      }
    }
  }
}`} lang="dart" title="BLoC Implementation Example" />

## Best Practices for Managing State in Flutter

### Keep Business Logic Out of UI

The most critical principle in Flutter state management is maintaining clear separation between business logic and UI components.

<Tabs>
  <TabItem label="Bad Practice">
    <Aside type="caution">
      Avoid placing business logic directly in the UI components.
    </Aside>

    <Code code={`// Bad Practice
class CounterWidget extends StatelessWidget {
  int count = 0;

  void increment() {
    count++;
  }

  @override
  Widget build(BuildContext context) {
    return Text('$count');
  }
}`} lang="dart" />
  </TabItem>

  <TabItem label="Good Practice">
    <Aside type="tip">
      Use `Cubit` or `Bloc` for handling logic instead of placing it in widgets.
    </Aside>

    <Code code={`// Good Practice
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0);

  void increment() => emit(state + 1);
}

class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CounterCubit, int>(
      builder: (context, count) {
        return Text('$count');
      },
    );
  }
}`} lang="dart" />
  </TabItem>
</Tabs>

### Use Immutable State

<Aside type="note">
  Ensure state objects are immutable to prevent unexpected UI behavior and make state changes predictable.
</Aside>

<Code code={`// Example of Immutable State
class CounterState {
  final int count;
  
  // Constructor with required final field
  const CounterState(this.count);
  
  // Copy with method for creating new instances
  CounterState copyWith({int? count}) {
    return CounterState(count ?? this.count);
  }
}`} lang="dart" title="Immutable State Example" />

### Minimize Widget Rebuilds

<Aside type="tip">
  Use `BlocSelector` or `BlocBuilder` efficiently to only rebuild widgets when necessary, improving app performance.
</Aside>

<Code code={`// Example of BlocSelector
BlocSelector<CounterCubit, int, bool>(
  selector: (state) => state % 2 == 0,
  builder: (context, isEven) {
    return Text(isEven ? 'Even' : 'Odd');
  },
);`} lang="dart" />

### Structure Your Code Properly

<Aside type="note">
  Organize your app into a Feature-Driven Architecture for better maintainability and team collaboration.
</Aside>

<FileTree>
- features
  - user_profile
    - domain
      - models
        - user_model.dart
      - providers
        - user_api_provider.dart
      - repository
        - user_repository.dart
    - logic
      - cubits
        - user_cubit.dart
      - states
        - user_state.dart
    - presentation
      - screens
        - user_profile_screen.dart
      - fragments
        - profile_header_fragment.dart
      - widgets
        - user_avatar.dart
</FileTree>

## Final Thoughts

<Aside type="tip">
  Choosing the right state management approach depends on your project's complexity and team requirements.
</Aside>

**BLoC is the best fit for our structured MVVM architecture**, ensuring clear separation of concerns, scalability, and maintainability. The event-driven approach provides predictable data flow and makes testing straightforward.

For very simple features or screens with minimal state changes, simpler approaches like Provider might reduce boilerplate code while still maintaining good architecture. Always evaluate the complexity of your feature and long-term maintenance requirements before deciding on a state management approach.

The key is consistency across your application - once you choose an approach, stick with it throughout your project to maintain code coherence and team productivity.

## See Also

1. [BLoC Package](https://pub.dev/packages/bloc) – The official BLoC package documentation
2. [Riverpod](riverpod) – Documentation for the Riverpod state management solution  
3. [Flutter Official Documentation](https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro) – Official Flutter documentation on state management