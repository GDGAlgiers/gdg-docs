---
title: "Project Structure"
description: "A structured approach to organizing Flutter projects using feature-driven architecture and MVVM pattern."
---

import { Aside, Code, FileTree, Card, CardGrid, Steps, Tabs } from '@astrojs/starlight/components';

<Aside>
  A well-organized project structure is key to maintaining scalability, readability, and ease of collaboration in Flutter applications. By following a structured approach, developers can ensure modularity and maintainability.  
  **Related Guide**: [Flutter State Management](../state-management)
</Aside>

---

## Feature-Driven Architecture

Feature-Driven Architecture (FDA) structures Flutter projects around self-contained features, each handling its UI, business logic, and state management. This ensures a modular, scalable, and maintainable codebase.

---

## Why Feature-Driven Architecture?

<CardGrid>
  <Card title="Modularity">
    Features are self-contained and reusable.
  </Card>
  <Card title="Scalability">
    New features can be added without disrupting existing ones.
  </Card>
  <Card title="Separation of Concerns">
    Clear division between UI, logic, and data layers.
  </Card>
  <Card title="Improved Collaboration">
    Teams can work on features independently.
  </Card>
  <Card title="Easier Testing & Maintenance">
    Isolated features simplify debugging and testing.
  </Card>
  <Card title="Faster Onboarding for New Developers">
    Features are self-contained, making it easier for new developers to understand and contribute.
  </Card>
</CardGrid>

This structure helps developers build maintainable and efficient Flutter apps.

---

## Getting Started

<Steps>
  1. **Create a new Flutter project:** 
     ```bash
     flutter create my_app
     ```
  2. **Set up the base folder structure:**
     <FileTree>
     - lib
       - features
       - shared
       - core
       - main.dart
     </FileTree>
  3. **Define your app's features and start coding!**
</Steps>

<Aside type="tip">
  For developers using VSCode, the [Flutter Feature Scaffolding](https://marketplace.visualstudio.com/items?itemName=KiritchoukC.flutter-clean-architecture) extension can automate feature folder creation.
</Aside>

---

## Suggested Folder Structure

This folder structure organizes features into distinct layers, ensuring a clean separation of concerns:

<FileTree>
- features
  - feature_1
  - feature_2
    - domain (Data Layer - Models, Providers, Repositories)
      - models        # Data Classes
      - providers     # Handles API/database interactions
      - repository    # Business logic interacting with models & providers
    - logic (Business Logic Layer - ViewModel equivalent)
      - cubits        # Handles state changes
      - states        # Defines different states
    - presentation (UI Layer - View equivalent)
      - screens       # Full-screen widgets
      - fragments     # Partial UI components
      - widgets       # Reusable UI elements
- shared              # Code shared between multiple features
- core                # Core functionality, constants, helpers, and routing
</FileTree>

---

## Architecture Flow Diagram

<Code code={`┌───────────────────┐     ┌───────────────────┐     ┌───────────────────┐
│   Presentation    │     │       Logic       │     │      Domain       │
│      Layer        │◄────┤      Layer        │◄────┤      Layer        │
│    (UI/View)      │     │   (ViewModel)     │     │ (Data/Models)     │
└───────────────────┘     └───────────────────┘     └───────────────────┘
        ▲                          │                          ▲
        │                          ▼                          │
        │                  ┌───────────────────┐              │
        └──────────────────┤  State Updates    ├──────────────┘
                           │ (Cubit to View)   │
                           └───────────────────┘`} lang="text" title="Architecture Flow" />

Data flows from the Domain Layer (API/DB) through the Logic Layer (state processing) to the Presentation Layer (UI). User interactions in the UI trigger actions in the Logic Layer, which may fetch or update data through the Domain Layer.

## Example Feature: User Profile

<FileTree>
- features
  - user_profile
    - domain
      - models
        - user_model.dart
      - providers
        - user_api_provider.dart
      - repository
        - user_repository.dart
    - logic
      - cubits
        - user_cubit.dart
      - states
        - user_state.dart
    - presentation
      - screens
        - user_profile_screen.dart
      - fragments
        - profile_header_fragment.dart
      - widgets
        - user_avatar.dart
</FileTree>

---

## Layer Breakdown

<Tabs>
  <Tabs label="Domain Layer">
    <Card title="Domain Layer">
      - **Models**: Define data structures (e.g., `UserModel`).  
      - **Providers**: Handle API/database communication.  
      - **Repositories**: Bridge between providers and business logic.  
      **Related**: [Clean Architecture in Flutter](https://resocoder.com/flutter-clean-architecture-tdd/)  
    </Card>

    ### Domain Layer Code Examples

    <Code code={`// features/user_profile/domain/models/user_model.dart
class UserModel {
  final String id;
  final String name;
  final String email;
  
  UserModel({required this.id, required this.name, required this.email});
  
  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'],
      name: json['name'],
      email: json['email'],
    );
  }
  Map<String, dynamic> toJson() {
       return {
          'id': id,
          'name': name,
          'email': email,
       };
     }
}`} lang="dart" title="User Model" />

    <Code code={`// features/user_profile/domain/repository/user_repository.dart
class UserRepository {
  final UserApiProvider apiProvider;

  UserRepository(this.apiProvider);

  Future<UserModel> getUser() async {
    final userData = await apiProvider.fetchUserProfile();
    return UserModel.fromJson(userData);
  }
}`} lang="dart" title="User Repository" />
  </Tabs>

  <Tabs label="Logic Layer">
    <Card title="Logic Layer">
      - **Cubits (ViewModel Layer)**: Manage state transitions efficiently.  
      - **States**: Immutable state classes (e.g., `UserLoaded`, `UserError`).  
    </Card>

    ### Logic Layer Code Examples

    <Code code={`// features/user_profile/logic/states/user_state.dart
abstract class UserState {}

class UserInitial extends UserState {}
class UserLoading extends UserState {}
class UserLoaded extends UserState {
  final UserModel user;
  UserLoaded(this.user);
}
class UserError extends UserState {
  final String message;
  UserError(this.message);
}`} lang="dart" title="User States" />

    <Code code={`// features/user_profile/logic/cubits/user_cubit.dart
class UserCubit extends Cubit<UserState> {
  final UserRepository repository;
  UserCubit(this.repository) : super(UserInitial());

  Future<void> fetchUserProfile() async {
    emit(UserLoading());
    try {
      final user = await repository.getUser();
      emit(UserLoaded(user));
    } catch (e) {
      emit(UserError(e.toString()));
    }
  }
}`} lang="dart" title="User Cubit" />
  </Tabs>

  <Tabs label="Presentation Layer">
    <Card title="Presentation Layer">
      - **Screens**: Full-page UIs (e.g., `UserProfileScreen`).  
      - **Fragments**: Reusable screen sections (e.g., `ProfileHeaderFragment`).  
      - **Widgets**: Atomic UI components (e.g., `UserAvatar`).  
      **Related**: [Flutter UI Best Practices](https://medium.com/@expertappdevs/performance-best-practices-in-flutter-4579a7a265da)  
    </Card>

    ### Presentation Layer Code Examples

    <Code code={`// features/user_profile/presentation/screens/user_profile_screen.dart
class UserProfileScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => getIt<UserCubit>()..fetchUserProfile(),
      child: Scaffold(
        appBar: AppBar(title: Text('User Profile')),
        body: BlocBuilder<UserCubit, UserState>(
          builder: (context, state) {
            if (state is UserLoading) {
              return Center(child: CircularProgressIndicator());
            } else if (state is UserLoaded) {
              return ProfileContent(user: state.user);
            }
            return Center(child: Text('Select a user'));
          },
        ),
      ),
    );
  }
}`} lang="dart" title="User Profile Screen" />

    <Code code={`// features/user_profile/presentation/widgets/user_avatar.dart
class UserAvatar extends StatelessWidget {
  final String avatarUrl;
  
  const UserAvatar({Key? key, required this.avatarUrl}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Container(
      width: 80,
      height: 80,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(color: Theme.of(context).primaryColor),
      ),
      child: ClipOval(
        child: Image.network(
          avatarUrl,
          fit: BoxFit.cover,
          errorBuilder: (_, __, ___) => Icon(Icons.person),
        ),
      ),
    );
  }
}`} lang="dart" title="User Avatar Widget" />
  </Tabs>
</Tabs>

---

## Applying the MVVM Pattern with Cubits

The **MVVM (Model-View-ViewModel)** pattern separates concerns, ensuring better maintainability and testability. **Cubits** (from the BLoC pattern) handle state management efficiently by maintaining immutable states.

<CardGrid>
  <Card title="ViewModel Layer">
    Implemented via Cubits that handle state transitions and business logic.
  </Card>
  <Card title="View Layer">
    Widgets observe Cubit states and react accordingly to state changes.
  </Card>
</CardGrid>

---

## Performance Considerations

This architecture impacts performance in several ways:

<CardGrid>
  <Card title="Memory Usage">
    Feature separation prevents unnecessary loading of unused components.
  </Card>
  <Card title="Build Time">
    Cubits rebuild only the specific widgets that depend on changed states, avoiding full UI rebuilds.
  </Card>
  <Card title="Tree Shaking">
    Properly structured code allows the Dart compiler to optimize away unused code.
  </Card>
  <Card title="Load Time">
    Consider lazy-loading features that aren't needed during initial app startup.
  </Card>
</CardGrid>

<Aside type="tip">
  **Optimization Tip**: Use `const` constructors for stateless widgets to leverage Flutter's widget tree optimization.
</Aside>

---

## Migrating Existing Projects

<Steps>
  1. **Identify Features**
     List distinct functionalities in your app.
  
  2. **Create Structure** 
     Set up the base folder structure alongside existing code.
  
  3. **Gradual Migration** 
     Move one feature at a time, starting with less complex ones.
  
  4. **Refactor State Management** 
     Gradually introduce Cubits for state management.
  
  5. **Update Imports** 
     Fix import paths throughout the codebase.
  
  6. **Test Thoroughly** 
     After each migration step, run tests to ensure functionality.
</Steps>

<Aside type="note">
  **Migration Strategy**: Keep the app functional throughout the process by maintaining interoperability between old and new architecture components.
</Aside>

---

## Best Practices

### 1. Dependency Injection

    Keep dependencies managed efficiently using a service locator like GetIt.

### 2. Modularity

    Keep features self-contained and avoid unnecessary dependencies between features.

### 3. Testing

    Keep dependencies managed efficiently using a service locator like GetIt.
    
<Aside type="caution">
  ### Avoid These Common Mistakes
  
  - **Placing business logic inside widgets** – Always separate concerns.
  - **Failing to emit distinct Cubit states** – Ensure states are immutable.
  - **Overusing singletons in dependency injection** – Use lazy singletons wisely.
</Aside>

---

## **See Also**
1. [State Management Fundamentals](../state-management) – Learn how to manage complex states effectively.  
2. [Feature-Driven Development in Flutter](https://codewithandrea.com/articles/flutter-project-structure/) – Comprehensive guide to feature-first Flutter architecture.
3. [Flutter Official Documentation](https://docs.flutter.dev) – Stay updated with the latest Flutter best practices.

---
