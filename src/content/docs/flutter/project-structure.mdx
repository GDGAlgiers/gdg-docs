---
title: "Flutter Project Structure"
description: "A structured approach to organizing Flutter projects using feature-driven architecture and MVVM pattern."
---

import { Aside, Code, FileTree, Card } from '@astrojs/starlight/components';


<Aside>
A well-organized project structure is key to maintaining scalability, readability, and ease of collaboration in Flutter applications. By following a structured approach, developers can ensure modularity and maintainability.  
**Related Guide**: [Flutter State Management](../state-management)
</Aside>

---

## **Feature-Driven Architecture**

Feature-driven architecture structures the project based on independent features, making the codebase modular, maintainable, and scalable. Each feature encapsulates its domain logic, UI, and state management. This approach promotes **separation of concerns** and improves team collaboration.

---

## **Getting Started**

To implement this structure in a new project:

1. Create a new Flutter project: `flutter create my_app`
2. Remove the default `lib/main.dart` boilerplate content
3. Set up the base folder structure:
   ```
   lib/
   ├── features/
   ├── shared/
   ├── core/
   └── main.dart
   ```
4. Define your app's features and create corresponding folders
5. Set up dependency injection in `core/injection.dart`

For developers using VSCode, the [Flutter Feature Scaffolding](https://marketplace.visualstudio.com/items?itemName=KiritchoukC.flutter-clean-architecture) extension can automate feature folder creation.

---

## **Suggested Folder Structure**

<FileTree>
- features
  - feature_1
  - feature_2
    - domain (Data Layer - Models, Providers, Repositories)
      - models        # Data Classes
      - providers     # API communication logic
      - repository    # Business logic interacting with models & providers
    - logic (Business Logic Layer - ViewModel equivalent)
      - cubits        # Handles state changes
      - states        # Defines different states
    - presentation (UI Layer - View equivalent)
      - screens       # Full-screen widgets
      - fragments     # Partial UI components
      - widgets       # Reusable UI elements
- shared              # Code shared between multiple features
- core                # Core functionality, constants, helpers, and routing
</FileTree>

---

## **Architecture Flow Diagram**

```
┌───────────────────┐     ┌───────────────────┐     ┌───────────────────┐
│   Presentation    │     │       Logic       │     │      Domain       │
│      Layer        │◄────┤      Layer        │◄────┤      Layer        │
│    (UI/View)      │     │   (ViewModel)     │     │ (Data/Models)     │
└───────────────────┘     └───────────────────┘     └───────────────────┘
        ▲                          │                          ▲
        │                          ▼                          │
        │                  ┌───────────────────┐              │
        └──────────────────┤  State Updates    ├──────────────┘
                           │ (Cubit to View)   │
                           └───────────────────┘
```

Data flows from the Domain Layer (API/DB) through the Logic Layer (state processing) to the Presentation Layer (UI). User interactions in the UI trigger actions in the Logic Layer, which may fetch or update data through the Domain Layer.

---

## **Example Feature: User Profile**

<FileTree>
- features
  - user_profile
    - domain
      - models
        - user_model.dart
      - providers
        - user_api_provider.dart
      - repository
        - user_repository.dart
    - logic
      - cubits
        - user_cubit.dart
      - states
        - user_state.dart
    - presentation
      - screens
        - user_profile_screen.dart
      - fragments
        - profile_header_fragment.dart
      - widgets
        - user_avatar.dart
</FileTree>

---

## **Applying the MVVM Pattern with Cubits**

The **MVVM (Model-View-ViewModel)** pattern separates concerns, ensuring better maintainability and testability. **Cubits** (from the BLoC pattern) handle state management efficiently by maintaining immutable states.

**Key Integration:**  
- **ViewModel Layer**: Implemented via Cubits.  
- **View Layer**: Widgets observe Cubit states and react accordingly.  

### **Code Example**

```dart
// features/user_profile/logic/cubits/user_cubit.dart
class UserCubit extends Cubit<UserState> {
  final UserRepository repository;
  UserCubit(this.repository) : super(UserInitial());

  Future<void> fetchUserProfile() async {
    emit(UserLoading());
    try {
      final user = await repository.getUser();
      emit(UserLoaded(user));
    } catch (e) {
      emit(UserError(e.toString()));
    }
  }
}
```

---

## **Layer Breakdown**

Flutter applications benefit from a clear separation of concerns. Each layer plays a critical role in maintaining modularity:

<Card title="Domain Layer">
- **Models**: Define data structures (e.g., `UserModel`).  
- **Providers**: Handle API/database communication.  
- **Repositories**: Bridge between providers and business logic.  
**Related**: [API Integration Guide](../api-integration-data-handling)  
</Card>

<Card title="Logic Layer">
- **Cubits (ViewModel Layer)**: Manage state transitions efficiently.  
- **States**: Immutable state classes (e.g., `UserLoaded`, `UserError`).  
**Related**: [Testing Cubits]()  
</Card>

<Card title="Presentation Layer">
- **Screens**: Full-page UIs (e.g., `UserProfileScreen`).  
- **Fragments**: Reusable screen sections (e.g., `ProfileHeaderFragment`).  
- **Widgets**: Atomic UI components (e.g., `UserAvatar`).  
**Related**: [UI Best Practices]()  
</Card>

---

## **Performance Considerations**

This architecture impacts performance in several ways:

- **Memory Usage**: Feature separation prevents unnecessary loading of unused components.
- **Build Time**: Cubits rebuild only the specific widgets that depend on changed states, avoiding full UI rebuilds.
- **Tree Shaking**: Properly structured code allows the Dart compiler to optimize away unused code.
- **Load Time**: Consider lazy-loading features that aren't needed during initial app startup.
<Aside type="tip">
**Optimization Tip**: Use `const` constructors for stateless widgets to leverage Flutter's widget tree optimization.
</Aside>

---

## **Migrating Existing Projects**

To migrate an existing Flutter project to this architecture:

1. **Identify Features**: List distinct functionalities in your app.
2. **Create Structure**: Set up the base folder structure alongside existing code.
3. **Gradual Migration**: Move one feature at a time, starting with less complex ones.
4. **Refactor State Management**: Gradually introduce Cubits for state management.
5. **Update Imports**: Fix import paths throughout the codebase.
6. **Test Thoroughly**: After each migration step, run tests to ensure functionality.
<Aside type="note">
**Migration Strategy**: Keep the app functional throughout the process by maintaining interoperability between old and new architecture components.
</Aside>

---

## **Best Practices**

<Aside type="tip">
- **Dependency Injection**: Keep dependencies managed efficiently.
  ```dart
  // core/injection.dart
  final getIt = GetIt.instance;
  void setupDependencies() {
    getIt.registerLazySingleton<UserRepository>(() => UserRepository());
  }
  ```
- **Modularity**: Keep features self-contained and avoid unnecessary dependencies.  
- **Testing**: Cover Cubits, Repositories, and critical widgets to ensure robustness.  

### **Avoid These Common Mistakes**
- ❌ **Mixing UI and business logic** – Always separate concerns.
- ❌ **Not handling states properly in Cubits** – Ensure states are immutable.
- ❌ **Overusing singletons in dependency injection** – Use lazy singletons wisely.

**See Also**: [Testing Strategies]()  
</Aside>

---

## **Further Reading**
1. [State Management Fundamentals](../state-management) – Learn how to manage complex states effectively.  
2. [Feature-Driven Development (FDD) Guide]() – Understand how feature-driven development improves maintainability.  
3. [Flutter Official Documentation](https://docs.flutter.dev) – Stay updated with the latest Flutter best practices.