---
title: "API Integration & Data Handling"
description: "Best practices for secure and efficient API communication in Flutter applications, including error handling and data serialization."
---

import {
  Aside,
  Code,
  FileTree,
  Steps,
  Tabs,
  TabItem,
} from "@astrojs/starlight/components";

Effective API integration is essential for modern Flutter applications that rely on backend services. Implementing secure, efficient, and resilient communication patterns ensures your app delivers a seamless user experience while protecting sensitive data.

<Aside type="tip">
  **Pro tip:** Plan your API integration strategy early in development, focusing
  on security, error handling, and efficient data serialization to create a
  robust foundation for your app.
</Aside>

## Choosing the Right HTTP Client

Flutter offers several libraries for API communication, each with distinct advantages for different use cases:

<Tabs>
  <TabItem label="HTTP Package">
    ### HTTP Package (Simple)
    
    Flutter's basic HTTP client package for straightforward API needs:
    
    - **Simple API with minimal boilerplate**: Quick setup for basic requests
    - **Part of Flutter's core packages**: No additional dependencies
    - **Lightweight implementation**: Perfect for simple API interactions
    
    **Use Case:** Best for small apps with basic API requirements and minimal complexity.

    <Code code={`dependencies:

http: ^1.1.0

// Basic usage
final response = await http.get(
Uri.parse('https://api.example.com/users'),
headers: {'Authorization': 'Bearer $token'},
);`} lang="yaml" />

  </TabItem>
  
  <TabItem label="Dio Package">
    ### Dio Package (Advanced)
    
    Feature-rich HTTP client with advanced capabilities:
    
    - **Built-in interceptors for request/response handling**: Automatic token management and logging
    - **Request cancellation and retry mechanisms**: Better user experience during network issues
    - **Form data and file upload support**: Comprehensive data handling capabilities
    - **Advanced error handling**: Structured error responses with detailed information
    
    **Use Case:** Recommended for production apps requiring robust API communication and advanced features.

    <Code code={`dependencies:

dio: ^5.3.2

// Advanced usage with interceptors
final dio = Dio()
..interceptors.add(AuthInterceptor())
..interceptors.add(LoggingInterceptor());`} lang="yaml" />

  </TabItem>
</Tabs>

## API Client Architecture

Implementing a structured API client is essential for maintainable code. We recommend using Dio with a repository pattern:

### Recommended Project Structure

<FileTree>
- lib
  - core
    - api
      - api_client.dart      # Core API client with Dio configuration
      - api_endpoints.dart   # Constant endpoint definitions
      - api_interceptors.dart # Custom interceptors
  - features
    - feature_1
      - data
        - repositories
          - feature_1_repository.dart # Feature-specific API calls
</FileTree>

### Base API Client Setup

<Code
  code={`// lib/core/api/api_client.dart
class ApiClient {
  late Dio _dio;
  static final ApiClient _instance = ApiClient._internal();
  factory ApiClient() => _instance;
  
  ApiClient._internal() {
    _dio = Dio(BaseOptions(
      baseUrl: AppConfig.apiBaseUrl,
      connectTimeout: const Duration(seconds: 30),
      headers: {'Content-Type': 'application/json'},
    ));
    
    // Add interceptors
    _dio.interceptors.addAll([
      AuthInterceptor(),
      LoggingInterceptor(),
      ErrorInterceptor(),
    ]);
  }
  
  Dio get dio => _dio;
}`}
  lang="dart"
  title="API Client Configuration"
/>

### Essential Interceptors

<Code code={`// lib/core/api/api_interceptors.dart
class AuthInterceptor extends Interceptor {
  @override
  Future<void> onRequest(
    RequestOptions options,
    RequestInterceptorHandler handler,
  ) async {
    final token = await SecureStorage().getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    handler.next(options);
  }
}

class ErrorInterceptor extends Interceptor {
@override
void onError(DioException err, ErrorInterceptorHandler handler) {
final apiError = ApiFailure.fromDioException(err);
handler.next(err);
}
}`} lang="dart" title="Core Interceptors" />

---

## Error Handling Strategy

Implement comprehensive error handling to provide users with meaningful feedback:

### Structured Error Classes

<Code code={`// lib/core/api/api_failure.dart
abstract class ApiFailure {
  final String message;
  final int? statusCode;
  
  const ApiFailure(this.message, this.statusCode);
  
  factory ApiFailure.fromDioException(DioException error) {
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
        return ConnectionTimeout();
      case DioExceptionType.badResponse:
        return ServerError(error.response?.statusCode);
      default:
        return UnexpectedError(error.message);
    }
  }
}

class ConnectionTimeout extends ApiFailure {
const ConnectionTimeout() : super('Connection timeout', null);
}

class ServerError extends ApiFailure {
const ServerError(int? statusCode) : super('Server error', statusCode);
}`} lang="dart" title="Error Handling Classes" />

### Repository Implementation

<Code
  code={`// lib/features/user_profile/domain/repositories/user_repository.dart
class UserRepository {
  final ApiClient _apiClient;
  
  UserRepository(this._apiClient);
  
  Future<User> getUser(String userId) async {
    try {
      final response = await _apiClient.dio.get('/users/\$userId');
      return User.fromJson(response.data);
    } catch (e) {
      throw ApiFailure.fromException(e);
    }
  }
  
  Future<User> updateUser(User user) async {
    try {
      final response = await _apiClient.dio.put(
        '/users/\${user.id}',
        data: user.toJson(),
      );
      return User.fromJson(response.data);
    } catch (e) {
      throw ApiFailure.fromException(e);
    }
  }
}`}
  lang="dart"
  title="Repository Pattern"
/>

---

## Secure Storage for Authentication

Protect sensitive data like tokens and API keys using secure storage:

<Code code={`dependencies:
  flutter_secure_storage: ^9.0.0

// lib/core/storage/secure_storage.dart
class SecureStorage {
static const \_storage = FlutterSecureStorage(
aOptions: AndroidOptions(encryptedSharedPreferences: true),
);

// Token management
Future<void> saveAccessToken(String token) async {
await \_storage.write(key: 'access_token', value: token);
}

Future<String?> getAccessToken() async {
return await \_storage.read(key: 'access_token');
}

Future<void> deleteAllTokens() async {
await \_storage.delete(key: 'access_token');
await \_storage.delete(key: 'refresh_token');
}
}`} lang="dart" title="Secure Token Storage" />

<Aside type="caution">
  **Security Note:** Never hardcode API keys or secrets in your app code. Use
  secure storage for tokens and consider server-side validation for critical
  operations.
</Aside>

---

## Data Serialization Approaches

Choose the right serialization approach based on your project's complexity:

<Tabs>
  <TabItem label="Manual Serialization">
    ### Manual JSON Handling
    
    Simple approach for small models with few fields:

    <Code code={`class User {

final String id;
final String name;
final String email;

User({required this.id, required this.name, required this.email});

factory User.fromJson(Map<String, dynamic> json) {
return User(
id: json['id'],
name: json['name'],
email: json['email'],
);
}

Map<String, dynamic> toJson() => {
'id': id,
'name': name,
'email': email,
};
}`} lang="dart" />

    **When to Use:** Simple models, learning purposes, or when you need full control over serialization logic.

  </TabItem>

  <TabItem label="json_serializable">
    ### Code Generation (Recommended)
    
    Automated serialization with code generation:

    <Code code={`dependencies:

json_annotation: ^4.8.1

dev_dependencies:
build_runner: ^2.3.3
json_serializable: ^6.7.1

// Model with annotations
@JsonSerializable()
class User {
final String id;
final String name;

@JsonKey(name: 'email_address')
final String email;

User({required this.id, required this.name, required this.email});

factory User.fromJson(Map<String, dynamic> json) => _\$UserFromJson(json);
Map<String, dynamic> toJson() => _\$UserToJson(this);
}`} lang="dart" />

    <Code code={`# Generate serialization code

flutter pub run build_runner build`} lang="bash" />

    **When to Use:** Medium to large projects with multiple models that need consistent serialization patterns.

  </TabItem>

  <TabItem label="freezed">
    ### Immutable Data Classes
    
    Comprehensive code generation with immutability:

    <Code code={`dependencies:

freezed_annotation: ^2.4.1

dev_dependencies:
freezed: ^2.4.2
json_serializable: ^6.7.1

@freezed
class User with \_\$User {
const factory User({
required String id,
required String name,
required String email,
}) = \_User;

factory User.fromJson(Map<String, dynamic> json) => \_\$UserFromJson(json);
}`} lang="dart" />

    **When to Use:** Complex applications requiring immutable data classes, pattern matching, and comprehensive model generation.

  </TabItem>
</Tabs>

---

## Handling API Errors in UI

Create user-friendly error handling in your UI components:

<Code code={`// In your BLoC or Cubit
class UserCubit extends Cubit<UserState> {
  final UserRepository _repository;
  
  Future<void> loadUser(String userId) async {
    emit(UserLoading());
    try {
      final user = await _repository.getUser(userId);
      emit(UserLoaded(user));
    } on ApiFailure catch (failure) {
      emit(UserError(failure.message));
    }
  }
}

// In your UI
BlocBuilder<UserCubit, UserState>(
builder: (context, state) {
if (state is UserLoading) {
return const CircularProgressIndicator();
} else if (state is UserLoaded) {
return UserProfile(user: state.user);
} else if (state is UserError) {
return ErrorWidget(
message: state.message,
onRetry: () => context.read<UserCubit>().loadUser(userId),
);
}
return const SizedBox.shrink();
},
)`} lang="dart" title="UI Error Handling" />

---

## Best Practices Summary

### API Integration Checklist

<Steps>
  1. **Choose the right HTTP client** based on your app's complexity 2.
  **Structure API clients** using the repository pattern 3. **Implement proper
  error handling** with structured error classes 4. **Use secure storage** for
  sensitive authentication data 5. **Choose appropriate serialization** based on
  model complexity 6. **Handle network errors gracefully** in the UI layer
</Steps>

### Common Pitfalls to Avoid

<Aside type="caution">
  **Avoid these common mistakes:** - **Hardcoding API endpoints** - Use
  constants and configuration files - **Ignoring timeout configurations** -
  Always set appropriate timeouts - **Not handling offline scenarios** -
  Implement proper connectivity checks - **Exposing sensitive data in logs** -
  Be careful with logging interceptors - **Blocking the UI thread** - Always use
  async/await for API calls
</Aside>

### Performance Considerations

**Request Optimization**: Implement caching strategies for frequently accessed data and consider request debouncing for search functionality.

**Memory Management**: Dispose of HTTP clients properly and avoid memory leaks in long-running operations.

**Network Efficiency**: Use compression, implement pagination for large datasets, and consider request batching where appropriate.

---

## See Also

1. [State Management](../state-management) – How to integrate API calls with state management
2. [Project Structure](../project-structure) – Organizing API-related code in your project
3. [Dio Package Documentation](https://pub.dev/packages/dio) – Comprehensive HTTP client for Flutter
4. [Flutter Secure Storage](https://pub.dev/packages/flutter_secure_storage) – Secure storage for sensitive data
