---
title: "Conventional Commits"
description: "Simple guide to writing clear, consistent commit messages"
---

import { Aside } from '@astrojs/starlight/components';

Write commit messages that are clear, consistent, and helpful for your team.

## Basic Format

```
type: description

# Example:
feat: add user login button
fix: resolve header styling issue
docs: update setup instructions
```

## Common Types

### Main Types:
- **feat**: New feature or functionality
- **fix**: Bug fix
- **docs**: Documentation changes
- **style**: Code formatting (no logic changes)
- **refactor**: Code improvement (no new features)
- **test**: Adding or updating tests
- **chore**: Build tasks, dependencies, etc.

## With Scope (Optional)

Add scope in parentheses for more context:

```bash
# Component-specific changes
git commit -m "feat(auth): add password reset flow"
git commit -m "fix(header): resolve mobile menu bug"

# Feature-specific changes  
git commit -m "feat(dashboard): add user statistics"
git commit -m "fix(payment): handle failed transactions"

# File-specific changes
git commit -m "docs(readme): add installation guide"
git commit -m "test(api): add user endpoint tests"
```f

## Real Examples from Our Workflow

### Feature Development:
```bash
# Working on user authentication
git commit -m "feat(auth): add login form component"
git commit -m "feat(auth): implement JWT token handling"
git commit -m "feat(auth): add logout functionality"
```

### Bug Fixes:
```bash
# Fixing issues found in testing
git commit -m "fix(ui): resolve button spacing issue"
git commit -m "fix(api): handle empty response error"
git commit -m "fix(mobile): fix responsive layout"
```

### Documentation:
```bash
# Updating project docs
git commit -m "docs: add component usage examples"
git commit -m "docs(api): document authentication endpoints"
git commit -m "docs: update contributing guidelines"
```

## Breaking Changes

For major changes that break existing functionality:

```bash
# Add exclamation mark
git commit -m "feat!: change API response format"
git commit -m "refactor!: update user data structure"

# Or use BREAKING CHANGE in body
git commit -m "feat: update user authentication

BREAKING CHANGE: Login endpoint now requires email instead of username"
```

## Multi-line Commits

For more complex changes:

```bash
git commit -m "feat(payment): add Stripe integration

- Add Stripe SDK configuration
- Implement payment form component  
- Add error handling for failed payments
- Update user dashboard to show payment status

Closes #123"
```

## Linking to Issues

Connect commits to GitHub issues:

```bash
# Reference issue
git commit -m "fix(auth): resolve login timeout issue

Fixes #45"

# Multiple issues
git commit -m "feat(dashboard): add user statistics

Implements #67, #68, #69"

# Close issue
git commit -m "feat(api): add user search endpoint

Closes #91"
```

## Quick Reference

### What Makes a Good Commit:
- **Clear**: Easy to understand what changed
- **Specific**: Focused on one change
- **Consistent**: Follows the same format
- **Helpful**: Useful for reviewing history

### Examples of Good vs Bad:

**Good:**
```bash
feat(auth): add password reset functionality
fix(ui): resolve header overlap on mobile
docs(api): add authentication examples
```

**Bad:**
```bash
stuff
fixed things
wip
update
```

## Team Benefits

### Why This Helps:
- **Code Reviews**: Reviewers understand changes quickly
- **Release Notes**: Automatically generate from commit types
- **Bug Tracking**: Easy to find when bugs were introduced
- **History**: Clean, readable project history

### Tools Integration:
- **GitHub**: Automatically links commits to issues
- **Release Tools**: Generate changelogs from commit types
- **CI/CD**: Trigger different actions based on commit type

<Aside type="tip">
  **Pro Tip**: Set up a commit message template to help remember the format:
  ```bash
  git config commit.template ~/.gitmessage
  ```
</Aside>

Keep it simple and be consistent! Your future self (and teammates) will thank you!

## AI-Powered Commit Message Generation

VS Code can automatically generate conventional commit messages for your changes using GitHub Copilot (requires a paid GitHub plan). This feature analyzes your staged changes and suggests appropriate commit messages that follow conventional commit standards.

### How to Use:

1. **Stage Your Changes**: Add the files you want to commit to the staging area
2. **Open Source Control**: Navigate to the Source Control panel in VS Code
3. **Generate Message**: Click the sparkle icon (âœ¨) next to the commit message box
4. **Review & Commit**: VS Code will analyze your changes and suggest a conventional commit message

![VS Code commit message generation interface](/commit-generation.png)

### Generated Result:

The AI will create properly formatted conventional commits based on your actual code changes:

![Example of AI-generated conventional commit message](/generateed-commit.png)

<Aside type="tip">
  **GitHub Copilot Benefits**: 
  - Analyzes your actual code changes to suggest relevant commit types
  - Automatically follows conventional commit format
  - Saves time while maintaining consistency
  - Learns from your project's commit history patterns
</Aside>

### When This Feature is Most Helpful:
- **Large Changes**: When you have multiple files with different types of changes
- **Complex Refactoring**: AI can identify the main purpose of your refactoring
- **Learning**: Great for teams new to conventional commits
- **Consistency**: Ensures all team members follow the same format

Remember: Always review the generated message to ensure it accurately describes your changes!

## Further Reading

- [Conventional Commits Guide in more details](https://www.conventionalcommits.org/en/v1.0.0/)
